import{a8 as a,i as o,o as t,aF as r}from"./chunks/framework.-UWVxQvf.js";const n="/dnd-editor/assets/intro.s-gGBipW.jpg",m=JSON.parse('{"title":"介绍","description":"","frontmatter":{"title":"介绍"},"headers":[],"relativePath":"base/introduction.md","filePath":"base/introduction.md"}'),d={name:"base/introduction.md"};function i(c,e,s,p,l,h){return t(),o("div",null,[...e[0]||(e[0]=[r('<h1 id="介绍" tabindex="-1">介绍 <a class="header-anchor" href="#介绍" aria-label="Permalink to &quot;介绍&quot;">​</a></h1><p>这个项目基于<code>web components</code>实现了一个可视化的页面编辑器，主要目的有两个，一个是现有项目快速整合到一起，另一个是将编辑器的底层逻辑与业务代码解耦，使开发人员的关注点象聚焦在业务组件的编写上。对于一些名词有疑问的参看<a href="./explain.html">名称解释</a>。</p><h2 id="快速整合" tabindex="-1">快速整合 <a class="header-anchor" href="#快速整合" aria-label="Permalink to &quot;快速整合&quot;">​</a></h2><p>一般来说，当需要可视化编辑时如果项目本身没有使用<code>微前端</code>等技术，那么势必会使用当前使用的语言来开发，但是这样一来当多个项目都需要可视化编辑器，但是技术栈不同时，不可避免的需要重复开发，尤其是对于一个编辑器中的底层逻辑。</p><p>而如果是类似<code>宜搭</code>使用的低代码引擎<code>LowCodeEngine</code>虽然做了底层的抽象封装，但是对于不同的语言还是难以使用。</p><p>快速集成除了对语言没有什么硬性要求之外，在样式上也不能对原项目造成影响。基于上面的考量，<code>web components</code>显然是一个合适的选择。</p><h2 id="关注点分离" tabindex="-1">关注点分离 <a class="header-anchor" href="#关注点分离" aria-label="Permalink to &quot;关注点分离&quot;">​</a></h2><p>这个项目通过<code>模块联邦</code>将一个可视化编辑器在物理意义上分成了两个模块，用做驱动视图渲染和组件配置的编辑器，以及由业务主导的组件和其配置。传统的可视化编辑器往往只是在目录结构上进行区分，阅读时存在一定程度上的负担，同时实际开发时往往会出于便利或者是一些个人风格在无关的地方修改代码，导致其它开发人员接手后容易踩坑。</p><p>关注点进行分离后，编辑器通过<code>npm包</code>引入，组件代码则是作为一套独立的代码去进行开发的，最大程度的限制了开发人员对代码的控制范围，从而进一步降低了开发人员接手代码后的维护难度。</p><h2 id="示意图" tabindex="-1">示意图 <a class="header-anchor" href="#示意图" aria-label="Permalink to &quot;示意图&quot;">​</a></h2><p><img src="'+n+'" alt="布局"></p>',11)])])}const u=a(d,[["render",i]]);export{m as __pageData,u as default};
